# part 1 - 함수형으로 사고하기

필자와 마찬가지로 우리는 대부분 객체지향 언어로 애플리케이션을 구축해왔을 것이다. 함수형 코드는 작성하기 어렵지는 않지만 오랫동안 틀에 박힌 습관을 벗어나 함수형으로 사고하는 법을 배우기란 결코 쉽지 않다.

1 장은 함수형 프로그래밍의 정의를 내리고 함수형을 받아들이려면 어떤 마음가짐을 가져야 하는지 알아보자. 순수함수, 불변성, 부수효과, 참조 투명서에 기반을 둔, 아주 중요한 기법 몇 가지도 함꼐 소개한다. 함수형 코드의 근간을 이루는 기본 기술을 익혀본다.

# chapter 1 - 함수형 길들이기

```md
이 장의 내용

- 함수형 사고방식
- 함수형 프로그램이의 정의와 필요성
- 불변성, 순수함수 원리
- 함수형 프로그래밍 기법 및 그것이 설계 전반에 미치는 영향
```

> 객체지향은 가동부를 캡슐화하여 코드의 이해를 돕는다.
>
> 함수형 프로그래밍은 가동부를 최소화하여 코드의 이해를 돕는다.

웹 플랫폼은 굉장히 빠른 속도로 발전 중이고 브라우저 역시 꾸준히 진화하고 있지만, 무엇보다 요즘은 최종 사용자들의 요건이 웹 애플리케이션 설계 방식에 지대한 영향을 미친다. 사람들은 유려한 외관에 리액티브 위젯이 달린, 네이티브 데스크톱 / 모바일 앱처럼 움직이는 웹 애플리케이션을 선호한다. 그러다 보니 JS 개발자들은 여러가지 구현 방안을 모색하면서 그중 최선의 결과를 내는 프로그래밍 패러다임과최상의 지침을 적용하기 시작했다.

어떤 문제는 객체지향 설계 방식으로도 해겨랗ㄹ 수 있지만, 자바스크립트는 상태 공유가 보편적인, 참으로 동적인 언어라서 조금만 시간이 지나도 복잡해지면서 가독성이 떨어지고 관리하기 어려운 코드가 되기 일쑤이다. 객체 지향 설계 방햐잉 잘못된 건 아니지만 현실의 문제를 해결하기엔 역부족이다. 최근 유행하기 시작한 리액티브 프로그래밍은 데이터 흐름고 ㅏ변경 전파에 초점을 둔다. JS 로 비동기 또는 이벤트 중심 코드를 다룰 때에도 이런 부분이 아주 중요하다. 전반적으로 보면, 이제 자바스크립트에서도 데이터 및 데이터를 다루는 함수에 대해 진지하게 고민하는 프로그래밍 패러다임이 필요한 시기가 도래했다. 우리가 자문해야할 애플리케이션의 설계 요소를 정리해보자

- 확장성 : 추가 기능을 지원하기 위해 계속 코드를 리팩토링해야 하는가?
- 모듈화 용이성 : 파일 하나를 고치면 다른 파일도 영향을 받는가?
- 재사용성 : 중복이 많은가?
- 테스트성 : 함수를 단위 테스트하기 어려운가?
- 헤아리기 쉬움 : 체계도 없고 따라가기 어려운 코드인가?

이 중 한가지라도 "예", "잘 모른다"라고 대답했다면 이책이 끝났을 때 생산성이 높아져있을 것이다. 함수형 프로그래밍이 바로 우리를 구원해줄 프로그래밍 패러다임이다. 단순한 개념에 근거한 FP 는 문제를 다른 사고방식으로 바라본다.

FP 는 새로운 API 가 아니다. 기본원리를 깨우치면 다른 문제 해결 방법이 아주 친근하고 당연하게 여겨질 것이다.

1 장은 함수형 프로그래밍이 무엇인지 살펴보고, 함수형 패러다임이 왜 중요하면서도 유용한지 설명한다.

1. 불변성, 순수함수의 핵심원리를 설명하고
2. 다양한 FP 기법과 이런 기법이
3. 프로그램 설계 방식에 어떤 영향을 주는지 알아보자.
4. FP 기법을 잘 알아두면 리액티브 프로그래밍을 쉽게 배울 수 있는데다
5. 복잡한 JS 코딩에 십분 활용할 수 있다.

일단 그전에, 함수형으로 사고하는 것이 왜 중요한지, JS 프로그램의 복잡성을 해결하는데 어떤 도움을 줄수 있는 지 이해해야 한다.

## 1.1 함수형프로그래밍은 유용한가?

함수형 프로그래밍이 요즘처럼 각광받은 적이 없다. 개발 커뮤니티와 주요 소프트웨어 회사들도 FP 기법을 이용하여 강력한 비즈니스 애플리케이션을 구축하는 것이 이롭다는 사실을 깨닫기 시작했기 때문이다. 요즘 많이 사용되는 언어대부분이 네이티브 도는 API 형태로 FP 를 지원한다. 이제 FP 스킬은 수요가 제법 높은 편인데, 앞으로 수년간 이런 추세는 지속될 전망이다.

JS 맥락에서 보면, FP 사고방식은 JS 만의 매우 표현적인 특성을 가다음어 깔끔하면서도 모듈적인, 테스트하기 좋고 간결한 코드를 작성하는데 도움이 된다. 결과적으로 업무 능률 또한 높아진다.

사실 JS 는 함수형스타일로 작성해야 더 효과적이라는 측면을 오랫동안 간과했다. JS 를 오해한 부분도 있찌만, 언어 내부에 상태를 적절히 관리할 장치가 마땅찮았던 이유도 있다. JS 는 짧은 스크립트는 문제 없지만 베이스가 커지면 상태관리를 개발자에게 떠넘기는 동적인 플랫폼이기 때문이다.

FP 는 우리를 지켜주는 수호신이 될것이다. 함수형으로 작성하면 대부분의 문제들이 해결된다. 전체 애플리케이션 품질을 향상시키는 동시에 언어를 더 잘 이해할 수 있게되니 스킬도 향상된다.

본질을 파하고 나면 FP 는 아주 직관적이다. FP 는 프레임워크나 도구가 아니다.

## 1.2 함수형 프로그래밍이란?

FP 란 한마디로 함수 사용을 강조하는 소프트웨어 개발 스타일이다. 조금 다른 사고방식으로 접근해야 하는데 단지 어떤 결과를 만드는 함수를 적용하는 그런 단순한 차원의 문제가 아니라 애플리케이션의 **부수효과를 방지하고** **상태 변이를 감소하며** **데이터의 제어 흐름과 연상을 추상** 하는 것이다.

여러 함수를 서로 합서앟고 평가해서 더 많은 기능을 탑재하는 것이 유일한 목표이다.

```js
doucment.querySelecetor('#msg').innerHTML = '<h1>hello world</h1>'

FP로 바꾸면 =>

var printMessage = run(addToDom('msg'), h1, echo);

printMessage('Hello world');
```

여기서 run 함수는 세 함수를 마치 자전거 체인처럼 연결해서 한 함수의 반환값이 다른 함수의 입력값으로 전달되게끔 한다.

기본적으로 마치 알고리즘의 초기 조건을 조정하듯, 본연의 기능은 그대로 간직한 채 코드를 쉽게 변경하기 위해 코드 자체를 매개변수화 하는 것이다.

print 를 확장

```js
var printMessage = run(console.log, repeat(2), h2, echo);

printMessage("Get Functional");
```

함수형 / 비 함수형 해법을 견주어보면 근본적으로 스타일이 다르다는 걸 알 수 있다. 결과는 같지만 코드는 완전 딴판이다. FP 특유의 선언적 개발 방식때문에 그렇다. FP 를 온전히 이해하려면 이면에 깔려있는 기본 개념을 숙지해야 한다.

- 선언적 프로그래밍
- 순수함수
- 참조 투명성
- 불변성

### 1.2.1 함수형 프로그래밍은 선언적

`함수형 프로그래밍은 큰 틀에서 선언적 프로그래밍 패러다임이다.` 내부적으로 코드를 어덯게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산 / 작업을 표현하는 사상이다. 아직 Java, C#, C++ 등의 구조적/객체지향 언어가 지원하는 명령형 또는 절차적 모델이 더 많이 쓰인다. 명령형 프로그램은 어떤 결과를 내기 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 죽 늘어 놓은 순차열에 불과하다.

다음은 명령형으로 짠 코드이다.

```js
var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for (let i = 0; i < array.length; i++) {
  array[i] = Math.pow(array[i], 2);
}
array; // -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

`명령형 프로그래밍은 컴퓨터에게 원하는 작업을 어떻게 하는지 상세히 이른다.` 이게 가장 흔한 코딩방법이다.

이와 달리 선언적 프로그래밍은 프로그램의 서술부와 평가부를 분리하여, 제어 흐름이나 상태 변화를 특정하지 않고도 프로그램 로직이 무엇인지를 표현식으로 나타낸다.

같은 작업이라도 함수형으로 접근하면, 개발자가 각 요소를 올바르게 작동시키는 일에만 전념하고 루프제어는 시스템의 다른 파트에 일임할 수 있다.

```js
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function(num) {
  return Math.pow(num, 2);
});
//=> [0,1,4,9,16,25,36,49,64,81]
```

이전 코드와 비교하면 루프 카운터를 관리하고 배열 인덱스에 정확하게 접근하는 일은 하지 않는다. 사실 코드가 길어지면 버그가 날 가능성도 높아지고, 일반 루프는 함수로 추상하지 않는 한 재사용 자체가 안된다. 지금부터 우리가 할 일이 바로 추상화 하는 작업이다.

위 식을 람다 표현식이나 화살표 함수를 사용하면..(람다 표현식은 함수 인수로 전달 가능한 익명함수를 대체할 수 있다.)

```js
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => Math.pow(num, 2));
//=> [0,1,4,9,16,25,36,49,64,81]
```

이 된다.

루프는 재사용하기도 어렵고 다른 연산에 끼워 놓기도 어려운 명령형 제어 구조물이다. 또한 반복할 때마다 상태가 바뀌기 떄문에 제거하는 것이 좋다.

그러나 함수형 프로그램은 `무상태성`, `불변성을` 지향한다. 무상태 코드는 전역 상태를 바꾸거나 혼선을 일으킬 가능성이 단 1%도 없다. 상태를 두지 않으려면 부수효과와 상태 변이를 일으키지 않는 `순수함수를` 써야한다.

### 1.2.2 순수함수와 부수효과

순수함수의 특성을 정리하면 다음과 같다.

- 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동한다. => 같은 값을 넣었을 떄 언제나 같은 값을 출력한다.
- 전역 객체나 레퍼런스로 전달된 매개 변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다.

위 두 조건을 성립하지 않는 함수는 모두 불순하다고 볼 수 있다.

```js
var counter = 0;
function increment() {
  return ++counter;
}
```

자신의 스코프에 없는 외부 변수 counter 를 읽고 수정하므로 불순하다. 외부 자원을 상대로 데이터를 읽고 쓰는 함수는 부수효과를 동반한다. Date.now()처럼 많이 쓰이는 날짜 / 시간 함수도 미리 헤아릴 수 잇는 일정한 결괏값을 내지 않기 때문에 순수함수가 아니다.

부수효과가 발생하는 상황은 다양하다.

- 전역 범위에서 변수, 속성, 자료구조를 변경
- 함수의 원래 인수 값을 변경
- 사용자 입력을 처리
- 예외를 일으킨 해당 함수가 붙잡지 않고 그대로 예외를 던짐
- 화면 또는 로그 파일에 출력
- HTML 문서, 브라우저 쿠키, DB 에 질의

역동적으로 움직이며 온갖 변경이 난무하는 프로그램에서 순수함수를 사용하기란 현실적으로 어려울 수 잇지만, 실제로 함수형 프로그래밍은 모든 상태 변이를 근절하자는 건 아니고, `상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다.`

사회보장번호로 학생 레코드를 검색하여 브라우저에 표시하는 명령형 프로그램을 개발중이라 가정하자. 다음 코드는 (객체 배열 같은)외부 객체 저장소와 연동하여 어떤 IO 작업을 수행하며 부수효과를 일으키는 전형적인 시나리오로 자주 언급될 것이다.

```js
function showStudent(ssn) {
  let student = db.find(ssn);
  if (student !== null) {
    document.querySelector(`#${elemnetId}`).innerHTML = `${studnet.ssn},
    ${student.firstname},
    ${student.lastname}`;
  } else {
    throw new Error("학생을 찾을 수 없다."); // 올바른 학생이 아니면 예외를 던진다.
  }
}

showStudent("444-44-4444");
```

이 함수는 확실히 자신의 스코프를 벗어나 몇가지 부수효과를 일으킨다.

- 변수 db 를 통해 데이터에 접근하는데, 함수 서명에는 이런 매개변수가 없으니 이는 외부 변수이다. 문제는 이 변수가 실행 중 언제라도 null 을 참조하거나 호출 단계마다 상이한 값을 가리키면 결괏값이 완전히 달라지고 프로그램의 무결성이 깨질 수 있다는 점이다.
- elementId 는 그 값이 언제라도 바뀔 수 있는 전역 변수라 이 함수가 어쩔 도리가 없다.
- HTMl 요소를 직접 고친다. HTML 문서는 그 자체로 가변적인, 전역 공유 자원이다.
- 학생 레코드를 찾지 못해 예외를 던지면 전체 프로그램의 스택이 툭 풀리면서 종료될 것이다.

위 코드는 외부 자원에 의존하므로 코드가 유연하지 않고 다루기가 힘들뿐더러 테스트 역시 어렵다. 반면 순수함수는 서명에 정규 매개변수를 빠짐없이 명시하므로 코드를 이해하고 사용하기가 쉽다.

함수형 마음가짐으로 방금 전 printMessage 프로그램에서 배웟던 내용을 실제 시나리오에 하나씩 적용해보자.

- 긴 함수를 하나의 목적을 가진 짧은 함수로 각각 분리한다.
- 함수가 해야할 작업에 필요한 인수를 모두 명시하여 부수효과 개수를 줄인다.

먼저 학생 레코드를 조회하는 일과 이를 화면에 그리는 일을 분리하자. 외부 저장소 및 DOM 과 연동하면서 비롯되는 부수효과는 당연히 불가피하지만, 조금이라도 더 다루기 쉽고 주요 로직에 충실한 코드로 떼어낼 수 는 있다. 여기서 `커링`이라는 유명한 FP 기법을 상요한다. `커링은 함수의 여러 인수를 부분적으로 나누어 세팅하는 것이다.` 다음 코드는 find 와 append 두 함수를 커링을 통해 쉽게 조합해서 실행 가능한 단항 함수로 나눈다.

```js
var find = curry((db, id) => {
  let obj = db.find(id);
  if (obj === null) {
    throw new Error("객체를 찾을 수 없다");
  }
  return obj;
});

var csv = student =>
  `${student.ssn}, ${student.firstname}, ${student.lastname}`;

var append = curry((selector, info) => {
  document.querySelector(selector).innerHTML = info;
});
```

한가지만 개선했는데 벌써 여러가지 장점이 눈에 띈다.

- 재사용 가능한 컴포넌트 3 개로 나뉘어 코드가 훨씬 유연해졌다.
- 이렇게 잘게 나뉜 함수를 재사용함녀 신경써서 관리할 코드 크기가 확 줄기 떄문에 생산성을 높일 수 있다.
- 프로그램이 해야 할 일들을 고수준에서 단계별로 명확하게 보여주는 선언적 스타일을 따르므로 코드 가독성이 향상된다.
- 무엇보다 중요한 건, HTML 객체와의 상호작용을 자체 함수로 빼내어 순수하지 않은 로직을 순수함수에서 배제했다는 점이다.

부수효과를 줄임으로써 외부 조건 변화에 덜 취약한 프로그램이 되었다. find 함수를 보면 예외를 내는 별도의 null 체크 분기문이 포함되어있다. 이처럼 함수가 일관도니 반환값을 보장하도록 해서 전체 함수 결과를 예측 가능한 방향으로 유도하면 여러모로 이롭다. 이것이 `참조 투명성`이라는 순수함수 본연의 특징이다.

### 1.2.3 참조투명성과 치환성

참조 투명성은 순수함수를 정의하는 좀 더 공식적인 방법이며, 여기서 순수성이란 함수의 인수와 결괏값 사이의 순수한 매핑 관계를 의미한다. `어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 참조 투명한 함수라고 한다.` 아래 코드는 참조 투명하지 않다.

```js
var counter = 0;

function increment() {
  return ++counter;
}
```

참조 투명한 함수로 만들려면 이 함수가 의존하는 상태, 즉 외부 변수를 제거하고 함수 서명에 정규 매개변수로 명시해야 한다.

```js
var increment = counter => counter + 1;
```

이제 같은 입력에 같은 값을 반환하는 안전한 함수이다.

`이런 함수는 코드를 테스트하기 쉽고 전체 로직을 파악하는 것도 쉽다.` 참조 투명성 혹은 등식 정합성은 수학에서 나온용어지만 프로그래밍 언어의 함수는 수학 함수처럼 움직이지 않기 때문에 전적으로 개발자의 숙제로 남는다. 아래는 명령형과 run 함수를 이용한 예제이다.

```js
// 명령형
increment();
increment();
print(counter); // 이 값은 counter의 초깃값에 의존하고 호출 도중 변경되면 값이 어떻게 변할지 알수 없다.

//함수형
var plus2 = run(increment, increment);
print(plus2(0));
// 항상 초깃값을 2만큼 증가시킨다.
```

함수형 으로 구축된 프로그램은 시스템의 상태를 머리속으로 그려보기 쉽고(멘털 모델) 코드를 재작성하거나 치환하더라도 원하는 겨로가를 얻을 수 있기 때문에 헤아리기 쉽다. 좀 더 구체적으로 살펴보면 주어진 입력을 처리해서 결과를 내는 일련의 함수들로 임의의 프로그램을 정희해보자 의사 형식(peseudo form)로 나타내보면

`Program = [Input] + [func1, func2, func3, ...]=> Output`

[func1, func2,...]가 모두 순수함수이면 결과를 바꾸지 않고 [var1, var2, var3,...]식으로 나열하여 프로그램을 쉽게 고칠 수 있다. 평균점수 예제 보면

```js
var input = [80, 90, 100];
var average = arr => divide(sum(arr), size(arr));
average(input);
```

참조 투명성 덕분에 체계적이고 수학적인 형태로 프로그램을 헤아린다.

```js
var sum = (total, current) => total + current;
var total = arr => arr.reduce(sum);
var size = arr => arr.length;
var divide = (a, b) => a / b;
var average = arr => divide(total(arr), size(arr));
average(input); // => 90
```

순수 함수형 프로그램의 밑바탕에는 이러한 사고방식이 내재되어 있으며, 부수효과가 있는 함수라면 이런 일이 가능하지 않다. 객체를 레퍼런스로 넘길 때 실수로 객체에 변이를 일으키지 않도록 주의해야한다.

### 1.2.4 불변 데이터 유지하기

불변 데이터는 한번 생성된 후에는 절대 바뀌지 않는다. 다르 ㄴ언어도 그렇듯이 문자열, 숫자 등 자바사크립트의 모든 기본형은 처음부터 불변이다. 그러나 배열 드으이 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 수 있다.

```js
var sortDesc = arr => {
  arr.sort((a, b) => b - a);
};
```

얼핏 보기에는 부수효과와 무관한 코드 같고 좋은 코드 같다. 인수로 받은 배열의 원소를 내림차순으로 정렬한 뒤 그대로 반환하는 정해진 임무를 문제없이 완수한다.

```js
var arr = [1, 2, 3, 4, 5];
sortDesc(arr); // => [5,4,3,2,1]
```

하지만 상태적 함수인 sort 는 원본 레퍼런스가 가리키는 배열의 원소를 정렬하는 부수효과를 일으킨다. 이는 언어 자체의 심각한 결함인데 다음장에서 살펴보자.

이제 좀 더 간면한 정의를 내보면
`함수형 프로그래밍은, 외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것이다.` 더이상 간명할 순 없다.

오늘날 JS 개발자가 직면한 문제의 원인은, 대부분 뚜렷한 체계 없이 분기 처리를 남발하고 외부 공유 변수에 지나치게 의존하는 덩치 큰 함수를 괴용하는 데 있다. 심지어 성공적이라는 작품조차 많은 파일이 한데 뒤섞여 추적/디버깅이 어려운 가변 전역 데이터를 공유하는 촘촘한 그물망이 형성된 경우가 있다.

함수를 순수 연산의 관점에서 데이터를 절대 변경하지 않는 고정된 작업 단위로 바라본다면 확실히 잠재적인 버그는 줄어들 것이다. 우리가 FP 를 코드에 도입해서 이득을 보려면, 복잡성을 극복하는 길로 안내하는 핵심 원리를 반드시 이해해야 한다.

## 1.3 함수형 프로그래밍의 좋은 점

함수형 프로그래밍의 덕을 보려면, 함수형으로 생각하며 적절한 도구를 구사할 줄 알아야 한다. 이 절에서는 `함수형 인지력`을 향상시켜야 보자. 직관적으로 단순한 함수들을 조합해서 완전한 해법을 제시할 수 있게 될 것이다.

FP 로 개발한 자바스크립트 애플리케이션은 어떤 점이 좋은 지 고수준에서 살펴보자.

- 간단한 함수들로 작업을 분해한다.
- 흐름 체인으로 데이터를 처리한다.
- 리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.

### 1.3.1 복잡한 작업을 분해하도록 유도

함수형 프로그램밍은 고수준에서 보면, 사실상 분해와 합성 간의 상호작용이라 할 수 있다. 이러한 양면성 덕분에 함수형 프로그램은 모듈적으로, 효율적으로 동작한다. 모듈성의 단위, 곧 작업 단위는 바로 함수 자신이다.

run 은 이 책에서 가장 중요한 합성이라는 기법을 구현한 함수로, 두 함수를 합성하면 첫 번째 함수의 결과를 다음 함수에 밀어 넣는 새로운 함수가 탄생한다. 두 함수 f,g 의 합성 함수를 수학적으로 쓰면

f(g(x))로 쓰고 'f 합성 g' 라고 읽는다. 두 함수를 섞어 쓰려면 당연히 인수 개수와 형식이 서로 맞아야된다.

다음은 함수명을 compose ㄹ 잡고 showStudent 의 합성을해보자

```js
var showStudent = (compose = (append("#student-info"), csv, find(db)));

showStudent("444-44-4444");
```

compose 함수는 함수형 애플리케이션의 모듈성과 재사용성을 학습하는데 매우 각별한 의미를 지닌다. 함수형으로 합성한 코드는 전체 표현식의 의미를 개별 조각의 의미이서 추론할 수 있다. 다른 패러다임에선 절대 이루기가 쉽지않다.

또한 함수 합성은 고 수준의 추상화를 통해 자세한 내막을 밝히지 않아도 코드가 수행하는 전단계를 일목요연하게 나타낸다. compose 는 다른 함수를 인수로 받으므로 고계함수라고 한다.

### 1.3.2 데이터를 매끄럽게 체이닝하여 처리

map 이외에도 쾌적하고 강력한 함수형 라이브러리를 이용하면 다양한 고계함수를 가져다 쓸 수 있다.

체인은 ($ 또는 jQuery 처럼) 같은 객체를 반환하는 순차적인 함수 호출이다. 체인도 합성처럼 코드를 간결 명료하게 작성하게 하고, 함수형은 물론 리액티브 자바스크립트 라이브러리에서도 활발히 쓰인다. 이번엔 다른 문제로 넘어가, 복수 과목을 수강한 학생들의 평균 점수를 계산하는 프로그램은 작성해보자.

```js
let enrollment - [
  {enrolled:2, grade: 100},
  {enrolled:2, grade: 80},
  {enrolled:1, grade:89}
];
// 명령형
var totalGrades =0;
var totalStudentsFound = 0;
for(let i=0; i<enrollment.length; i++){
  let student = enrollment[i];
  if(student !==null){
    if(student.enrolled>1){
      totalGrades +=student.grade;
      totalStudentsFound++;
    }
  }
}
var average = totalGrades / totalStudentFound; //=>90
```

위 문제를 세가지 단꼐로 분해해보면

- (수강 과목이 2 개 이상인)자료 집합을 적절히 선택한다.
- 학생의 점수를 얻는다.
- 평균 점수를 계산한다.

함수 체인은 필요한 시점까지 실행을 미루는 느긋한 평가를 수행한다. 다른 데에선 전혀 쓸일이 없고 일련의 코드를 전부 실행하지 않아도 되니 CPU 부하가 줄어들고 성능이 좋아진다.

```js
//함수 체인 프로그래밍
_.chain(enrollment)
  .filter(student => student.enrolled > 1)
  .pluck("grade")
  .average()
  .value(); // => 90
// _.value()를 호출해야 체인에 연결된 모든 연산들이 실행된다.
```

지금 코드 로직을 깊이 파고들 필요없다. 선언형으로 함수 체인으로 프로그래밍했다 정도만 기억하자.

하지만 공정하게 보자면 위 예제는 실제로 우리가 사용하는 프로그램에 삽입기 마련인 많은 에러 처리 코드를 모두 무시하고 건너뛰었다. 예외를 던지는 건 부수효과를 유발한다고 했었다. 순수 학문적인 함수형 프로그래밍에는 예외가 존재하지 않지만, 실세계에서 예외를 완전히 배제하기란 어렵다. 순수 에러 처리와 예외 처리는 구별해야 하는데, 어쩄든 우리의 목표는 가급적 순수 에러 처리를 하도록 구현하고, 이전 코드처럼 진짜 예외적인 상황에서는 예외가 나게끔 허용하는 것이다.

다행히 몇몇 순수 함수형 디자인 패턴을 적용하면 풍부한 표현성을 희생하지 않고도 탄탄한 에러 처리 로직을 구사할 수 있다.

### 1.3.3 복잡한 비동기 애플래케이션에서도 신속하게 반응

콜백 패턴은 성공/실패 처리 로직이 중첩된 형태로 흩뿌려져 있기 때문에 코드의 선형 흐름이 깨지고 무슨 일을 하는지 파악하기 어렵다.

현재 RXJS 처럼 FP 의 강력한 장점으로 무장하여 난제를 척척 해결하는 신흥 강자들이 실무에 등장하고 있다.

자바스크립트 개발자들이 서버는 물론 클라이언트 측에서 매일매일 씨름하는 비동기 코드, 이벤트, 중심 코드으 ㅣ복잡도를 현허자헥 줄이는 데 큰 도움이 된다.

리액티브 패러다임의 가장 큰 장점은, 더 높은 수준으로 코드를 추상하여 비동기, 이벤트 기반 프로그램을 설정하느라 반복되는 판박이 코드는 아예 잊고 비즈니스 로직에만 전념할 수 있게 해준다.

- 학생의 SSN 을 읽고 올바른지 검증하는 명령형 프로그램

```js
var valid = false;
var elem = document.querySelector('#student-ssn');
elem.onkeyup = function(event){
  var val = elem.value;
  if(val!==null && val.length !==0){
    val = val.replace(/^\s*|\s*$|\-s/g, '');
    if(val.length===9){
      console.log(`올바른 SSN: ${val}!`);
      valid = true;
    }
  }
  else{
    console.log(잘못된 SSn: ${val}!`);
  }
};
```

하려는 일은 단순한데 코드는 적잖이 복잡해 보이고, 게다가 비즈니스 로직이 모두 한곳에 집중되어 있어 모듈성도 결여되어 있다. 무엇보다 이 함수는 외부 상태에 의존하는 탓에 재사용이 어렵다. 함수형 프로글매이에 기반을 둔 리액티브 프로그램은 순수함수를 이용하여 map, reduce 처럼 많이 쓰는 연산으로 데이터를 처리할 수 잇고 람다 표현식의 간결함을 누릴 수 있다는 이점이 있다. 사실 함수형을 마스터 했다면 리액티브 학습도 거의 절반은 끝난것ㅇ디ㅏ.

리액티브 패러다임은 `옵저버블`이라는 아주 중요한 장치를 매개로 움직ㅇ니다. 옵저버블을 이용하면 데이터 스트림을 구독해서 원하는 연산을 우하하게 합성 및 체이닝하여 처리할 수 있따. 학생 SSN 입력 필드를 구독하는 간단한 예를 들어보자.

- 함수형 프로그래밍

```js
Rx.Observable.fromEvent(document.querySelector("#student-ssn"), "keyup")
  .pluck("srcElement", "value")
  .map(ssn => ssn.replace(/^\s*|\s*$|\-/g, ""))
  .filter(ssn => ssn != null && ssn.length === 9)
  .subscribe(validSsn => {
    console.log(`올바른 SSN${validSsn}!`);
  });
```

수행하는 모든 연산이 완전한 불변이고 비즈니스 로직은 모두 개별 함수로 나뉘었다는 점이다. 굳이 리액티브/함수형을 섞어 쓸 필요는 없지만, 함수형으로 사고하다보면 두가지를 혼용하게 되어 결국 `함수형 리액티브프로그래밍`이라는 기막힌 아키텍처를 사용하게 된다.

FP 는 불변성과 공유 상태를 엄격하게 통제하므로 멀티스레드 프로그램도 보다 직관적으로 작성할 수 있다. 자바스크립트는 싱글스레드로 작동하는 플랫폼이므로 멀티스레드는 우리가 걱정하거나 이 책에서 다룰 주제는 아니다.

기존 OOP 의 명령형/절차적 스타일에 길들여진 우리가 함수형으로 전환하려면 지금부터 모든 문제를 '함수형'으로 바라보기 시작해야한다.
